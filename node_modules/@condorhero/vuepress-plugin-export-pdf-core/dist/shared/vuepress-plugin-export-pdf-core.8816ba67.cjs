'use strict';

const node_path = require('node:path');
const process = require('node:process');
const fse = require('fs-extra');
const pc = require('picocolors');
const htmlExportPdfCli = require('html-export-pdf-cli');
const node_os = require('node:os');
const multimatch = require('multimatch');
require('semver');
const mergePdfs = require('@condorhero/merge-pdfs');
const pdf = require('pdfjs');
require('cac');
require('bundle-require');
require('envinfo');
require('ora');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const process__default = /*#__PURE__*/_interopDefaultCompat(process);
const fse__default = /*#__PURE__*/_interopDefaultCompat(fse);
const pc__default = /*#__PURE__*/_interopDefaultCompat(pc);
const multimatch__default = /*#__PURE__*/_interopDefaultCompat(multimatch);
const pdf__default = /*#__PURE__*/_interopDefaultCompat(pdf);

const DOS_DEVICE_PATH_RE = /^\\\\(?<path>[.?])/;
const WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
function convertPathToPosix(path) {
  return node_os.platform() === "win32" ? path.replace(DOS_DEVICE_PATH_RE, "//$1").replaceAll(WINDOWS_BACKSLASHES_RE, "/") : path;
}

function filterRoute(pages, routePatterns) {
  const pagePaths = multimatch__default(pages.map(({ path }) => path), routePatterns);
  return pages.filter(({ path }) => pagePaths.includes(path));
}

async function mergePDF(pages, outFile, outDir, pdfOutlines = true) {
  const saveDirPath = node_path.join(process__default.cwd(), outDir);
  outDir && fse__default.ensureDirSync(saveDirPath);
  const saveFilePath = node_path.join(saveDirPath, outFile);
  if (pages.length === 0) {
    process__default.stdout.write(pc__default.red("The website has no pages, please check whether the export path is set correctly"));
    process__default.exit(1);
  } else if (pages.length === 1) {
    fse__default.moveSync(pages[0].pagePath, saveFilePath, { overwrite: true });
  } else {
    let pdfData;
    if (pdfOutlines) {
      pdfData = await mergePdfs.mergePDFs(pages.map(({ pagePath }) => {
        const relativePagePath = node_path.relative(process__default.cwd(), pagePath);
        return convertPathToPosix(relativePagePath);
      }));
    } else {
      const doc = new pdf__default.Document();
      pages.map(({ pagePath }) => fse__default.readFileSync(pagePath)).forEach((pdfFileItem) => {
        const pageFile = new pdf__default.ExternalDocument(pdfFileItem);
        doc.addPagesOf(pageFile);
      });
      pdfData = await doc.asBuffer();
    }
    fse__default.writeFileSync(saveFilePath, pdfData, { encoding: "binary" });
  }
  return node_path.relative(process__default.cwd(), saveFilePath);
}

async function generatePdf({
  pages,
  tempDir,
  port,
  host,
  sorter,
  outFile,
  outDir,
  urlOrigin,
  pdfOptions,
  pdfOutlines,
  routePatterns,
  puppeteerLaunchOptions,
  outlineContainerSelector
}) {
  const tempPdfDir = node_path.join(tempDir, "pdf");
  fse__default.ensureDirSync(tempPdfDir);
  let exportPages = filterRoute(pages, routePatterns);
  if (typeof sorter === "function")
    exportPages = exportPages.sort(sorter);
  const isValidUrlOrigin = htmlExportPdfCli.isValidUrl(urlOrigin ?? "");
  if (urlOrigin && !isValidUrlOrigin) {
    process__default.stdout.write(pc__default.red(`${urlOrigin} is not a valid URL`));
    process__default.exit(1);
  }
  let userURLOrigin = "";
  if (urlOrigin && isValidUrlOrigin)
    userURLOrigin = new URL(urlOrigin).origin;
  const localURLOrigin = `${host}:${port}`;
  const normalizePages = exportPages.map((page) => {
    return {
      url: page.path,
      title: page.title,
      location: urlOrigin ? `${userURLOrigin}${page.path}` : `http://${localURLOrigin}${page.path}`,
      pagePath: `${tempPdfDir}/${page.key}.pdf`
    };
  });
  const singleBar = htmlExportPdfCli.createProgress();
  singleBar.start(normalizePages.length);
  const printer = new htmlExportPdfCli.Printer({ outlineContainerSelector });
  await printer.setup(puppeteerLaunchOptions);
  for (const { location, pagePath, title } of normalizePages) {
    const page = await printer.createNewPage(location);
    if (urlOrigin && isValidUrlOrigin) {
      await page.setRequestInterception(true);
      page.on("request", (request) => {
        const reqUrl = request.url();
        if (htmlExportPdfCli.isValidUrl(reqUrl)) {
          const parsedUrl = new URL(reqUrl);
          if (userURLOrigin === parsedUrl.origin) {
            parsedUrl.host = host;
            parsedUrl.protocol = "http:";
            parsedUrl.port = `${port}`;
            const parsedUrlString = parsedUrl.toString();
            request.continue({
              url: parsedUrlString,
              headers: Object.assign(
                {},
                request.headers(),
                {
                  refer: parsedUrlString
                  // Same origin
                  // origin: parsedUrl.origin,
                  // CORS
                  // host: parsedUrl.host,
                }
              )
            });
          } else {
            request.continue();
          }
        } else {
          request.continue();
        }
      });
    }
    await printer.render(location);
    const headTitle = title || await page.title();
    const data = await printer.pdf(location, {
      format: "A4",
      ...pdfOptions
    });
    await htmlExportPdfCli.writeFileSafe(pagePath, data);
    await printer.closePage(location);
    singleBar.increment(1, { headTitle });
  }
  singleBar.stop();
  await printer.closeBrowser();
  const exportedPath = await mergePDF(normalizePages, outFile, outDir, pdfOutlines);
  const message = `
Exported to ${pc__default.yellow(exportedPath)}
`;
  process__default.stdout.write(message);
  fse__default.removeSync(tempPdfDir);
  !fse__default.readdirSync(tempDir).length && fse__default.removeSync(tempDir);
  return exportedPath;
}

exports.convertPathToPosix = convertPathToPosix;
exports.filterRoute = filterRoute;
exports.generatePdf = generatePdf;
exports.mergePDF = mergePDF;
